/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export const enum PaddingLevel {
  None = 0,
  Reduced = 1,
  Normal = 2
}
export type NativeTorClient = TorClient
export declare class TorClient {
  /**
  * Creates a new instance of the Tor client.
  *
  * If a builder is provided, it will be used to configure and build the client.
  * Otherwise, a default builder will be used.
  *
  * @param builder - Optional reference to a `NativeTorClientBuilder` to customize the client configuration.
  *
  * @returns A new `NativeTorClient` instance wrapped in a Promise.
  */
  static create(builder?: NativeTorClientBuilder | undefined | null): Promise<NativeTorClient>
  /**
  * Return a new isolated TorClient handle.
  * The two TorClients will share internal state and configuration, but their streams will never share circuits with one another.
  * Use this function when you want separate parts of your program to each have a TorClient handle, but where you don't want their activities to be linkable to one another over the Tor network.
  * Calling this function is usually preferable to creating a completely separate TorClient instance, since it can share its internals with the existing TorClient.
  * Connections made with clones of the returned TorClient may share circuits with each other.)
  */
  isolated(): TorClient
  /**
  * Launch an anonymized connection to the provided address and port over the Tor network.
  * Note that because Tor prefers to do DNS resolution on the remote side of the network, this function takes its address as a string:
  *
  *  @param address - The target address and port as a string, **important:** it must be in the format `url:port` (e.g. `"httpbin.org:80"`).
  *
  * @example
  * ```ts
  * const client = await TorClient.create();
  * const stream = await client.connect("httpbin.org:80");
  *
  * // It is recommended to wait for the connection to be fully established
  * // by calling `waitForConnection()` after `connect()`.
  * await stream.waitForConnection();
  * ```
  */
  connect(address: string): Promise<NativeTorStream>
  /**
  * Sets the default preferences for future connections made with this client.
  * The preferences set with this function will be inherited by clones of this client, but updates to the preferences in those clones will not propagate back to the original. I.e., the preferences are copied by clone.
  * Connection preferences always override configuration, even configuration set later (eg, by a config reload).
  */
  setStreamPrefs(streamPrefs: NativeStreamPrefs): this
  /**
  * Creates and returns a new hidden service.
  */
  createOnionService(onionServiceConfig: NativeOnionServiceConfig): NativeOnionService
  /**
  * Creates a new hidden service using a provided private key.
  * The key format must have the private key in the first 32 bytes.
  */
  createOnionServiceWithKey(onionServiceConfig: NativeOnionServiceConfig, bytes: Buffer): NativeOnionService
}
export type NativeTorClientBuilder = TorClientBuilder
export declare class TorClientBuilder {
  /**
  * Constructs a new `TorClientBuilder` with an optional configuration.
  *
  * If a configuration is provided, it will be used to initialize the builder.
  * Otherwise, the default configuration will be applied.
  *
  * @param config - Optional configuration object to customize the Tor client builder.
  * @returns A new instance of `NativeTorClientBuilder`.
  */
  constructor(config?: NativeTorClientConfig | undefined | null)
  /**
  * Constructs a new `TorClientBuilder` with an optional configuration.
  *
  * If a configuration is provided, it will be used to initialize the builder.
  * Otherwise, the default configuration will be applied.
  *
  * @param config - Optional configuration object to customize the Tor client builder.
  * @returns A new instance of `NativeTorClientBuilder`.
  */
  static create(config?: NativeTorClientConfig | undefined | null): NativeTorClientBuilder
  /**
  * Set the configuration for the TorClient under construction.
  * If not called, then a compiled-in default configuration will be used.
  */
  config(config: NativeTorClientConfig): this
}
export declare class ConfigCircuitTiming {
  /**
  * How long after a circuit has first been used should we give it out for new requests?
  */
  maxDirtiness(millis: number): this
  /**
  * When waiting for requested circuits,
  * wait at least this long before using a suitable-looking circuit launched by some other request.
  */
  requestLoyalty(millis: number): this
  /**
  * When a circuit is requested, we stop retrying new circuits after this many attempts.
  */
  requestMaxRetries(retries: number): this
  /**
  * When a circuit is requested, we stop retrying new circuits after this much time.
  */
  requestTimeout(millis: number): this
}
export declare class ConfigDirectoryTolerance {
  /**
  * For how long before a directory document is valid should we accept it?
  * Having a nonzero value here allows us to tolerate a little clock skew.
  * Defaults to 1 day.
  */
  preValidTolerance(millis: number): this
  /**
  * For how long after a directory document is valid should we consider it usable?
  * Having a nonzero value here allows us to tolerate a little clock skew,
  * and makes us more robust to temporary failures for the directory authorities to reach consensus.
  * Defaults to 3 days (per prop212).
  */
  postValidTolerance(millis: number): this
}
export declare class ConfigDownloadSchedule {
  /**
  * Top-level configuration for how to retry our initial bootstrap attempt.
  */
  retryBootstrap(): this
  /**
  * Configuration for how to retry an authority cert download.
  */
  retryCerts(): this
  /**
  * Configuration for how to retry a consensus download.
  */
  retryConsensus(): this
  /**
  * Configuration for how to retry a microdescriptor download.
  */
  retryMicrodescs(): this
}
export declare class ConfigNetParams {
  /**
  * Facility to override network parameters from the values set in the consensus.
  */
  overrideNetParams(key: string, value: number): this
}
export declare class ConfigPathRules {
  /**
  * Set the length of a bit-prefix for a default IPv4 subnet-family.
  * Any two relays will be considered to belong to the same family if their IPv4 addresses share at least this many initial bits.
  */
  ipv4SubnetFamilyPrefix(value: number): this
  /**
  * Set the length of a bit-prefix for a default IPv6 subnet-family.
  * Any two relays will be considered to belong to the same family if their IPv6 addresses share at least this many initial bits.
  */
  ipv6SubnetFamilyPrefix(value: number): this
  /**
  * Set the whole list (overriding the default)
  */
  setLongLivedPorts(values: Array<number>): this
  /**
  * Set the whole list (overriding the default)
  * e.g: "127.0.0.0/8:*"
  */
  setReachableAddrs(values: Array<string>): this
}
export declare class ConfigPreemptiveCircuits {
  /**
  * If we have at least this many available circuits, we suspend construction of preemptive circuits. whether our available circuits support our predicted exit ports or not.
  */
  disableAtThreshold(value: number): this
  /**
  * How many available circuits should we try to have, at minimum, for each predicted exit port?
  */
  minExitCircsForPort(value: number): this
  /**
  * After we see the client request a connection to a new port, how long should we predict that the client will still want to have circuits available for that port?
  */
  predictionLifetime(millis: number): this
  /**
  * Set the whole list (overriding the default)
  */
  setInitialPredictedPorts(ports: Array<number>): this
}
export declare class ConfigStorage {
  /**
  * Location on disk for cached information.
  * This follows the rules for /var/cache: "sufficiently old" filesystem objects in it may be deleted outside of the control of Arti, and Arti will continue to function properly. It is also fine to delete the directory as a whole, while Arti is not running.
  */
  cacheDir(dir: string): this
  /**
  * Location on disk for less-sensitive persistent state information.
  */
  stateDir(dir: string): this
  /**
  * Whether keystore use is enabled.
  */
  keystore(enabled: boolean): this
}
export declare class ConfigStreamTimeouts {
  /**
  * How long should we wait before timing out a stream when connecting to a host?
  */
  connectTimeout(millis: number): this
  /**
  * How long should we wait before timing out when resolving a DNS PTR record?
  */
  resolvePtrTimeout(millis: number): this
  /**
  * How long should we wait before timing out when resolving a DNS record?
  */
  resolveTimeout(millis: number): this
}
export type NativeTorClientConfig = TorClientConfig
export declare class TorClientConfig {
  constructor()
  static create(): NativeTorClientConfig
  /**
  * Should we allow attempts to make Tor connections to local addresses?
  * This option is off by default, since (by default) Tor exits will always reject connections to such addresses
  */
  allowLocalAddrs(value: boolean): this
  /**
  * Padding conf
  */
  padding(level: PaddingLevel): this
  /**
  * Circuit timing conf
  */
  get circuitTiming(): ConfigCircuitTiming
  /**
  * Directory tolerance conf
  */
  get directoryTolerance(): ConfigDirectoryTolerance
  /**
  * Download schedule conf
  */
  get downloadSchedule(): ConfigDownloadSchedule
  /**
  * Net params conf
  */
  get netParams(): ConfigNetParams
  /**
  * Path rules conf
  */
  get pathRules(): ConfigPathRules
  /**
  * Preemptive circuits conf
  */
  get preemptiveCircuits(): ConfigPreemptiveCircuits
  /**
  * Storage conf
  */
  get storage(): ConfigStorage
  /**
  * Stream timeouts conf
  */
  get streamTimeouts(): ConfigStreamTimeouts
}
export type NativeOnionServiceConfig = OnionServiceConfig
export declare class OnionServiceConfig {
  constructor()
  static create(): OnionServiceConfig
  /**
  * The nickname used to look up this service's keys, state, configuration, etc.
  */
  nickname(nickname: string): void
}
export type NativeRendRequest = RendRequest
export declare class RendRequest {
  /**
  * This class cannot be constructed manually.
  */
  constructor()
  /**
  * Mark this request as accepted, and try to connect to the client's provided rendezvous point.
  */
  accept(): Promise<NativeStreamsRequest | null>
  /**
  * Reject this request. (The client will receive no notification.)
  */
  reject(): Promise<void>
}
export type NativeOnionService = OnionService
export declare class OnionService {
  /**
  * This class cannot be constructed manually.
  */
  constructor()
  /**
  * Retrieves the next RendRequest in the queue.
  */
  poll(): Promise<RendRequest | null>
  /**
  * Return the onion address of this service.
  * Clients must know the service's onion address in order to discover or connect to it.
  * Returns `null|undefined` if the HsId of the service could not be found in any of the configured keystores.
  */
  address(): string | null
}
export type NativeStreamRequest = StreamRequest
export declare class StreamRequest {
  /**
  * This class cannot be constructed manually.
  */
  constructor()
  /**
  * Returns whether the current incoming stream request is a `Begin` request.
  * This indicates the start of a new incoming stream.
  */
  isBegin(): boolean
  /**
  * Returns the destination address for the incoming `Begin` stream request.
  * If the current request is a `Begin` request, returns the address as a byte vector.
  * Otherwise, returns `null|undefined`.
  */
  addr(): Array<number> | null
  /**
  * Returns the destination port for the incoming `Begin` stream request.
  * If the current request is a `Begin` request, returns the port number.
  * Otherwise, returns `None`.
  */
  port(): number | null
  /**
  * Accept this request and send the client a CONNECTED message.
  * Returns a TorStream.
  */
  accept(): Promise<NativeTorStream | null>
  /**
  * Reject this request, and send the client an END message.
  */
  reject(): Promise<void>
  /**
  * Reject this request and close the rendezvous circuit entirely, along with all other streams attached to the circuit.
  */
  shutdownCircuit(): Promise<void>
}
export type NativeStreamsRequest = StreamsRequest
export declare class StreamsRequest {
  /**
  * This class cannot be constructed manually.
  */
  constructor()
  /**
  * Retrieves the next StreamRequest in the queue.
  */
  poll(): Promise<StreamRequest | null>
}
export type NativeTorStream = TorStream
export declare class TorStream {
  /**
  * This class cannot be constructed manually.
  */
  constructor()
  /**
  * Wait until a CONNECTED cell is received, or some other cell is received to indicate an error.
  * Does nothing if this stream is already connected.
  */
  waitForConnection(): Promise<void>
  /**
  * Attempts to write an entire buffer into this writer.
  * @example
  * ```ts
  * const client = await TorClient.create();
  * const stream = await client.connect("httpbin.org:80");
  * const request =
  *   "GET / HTTP/1.1
  " +
  *   "Host: httpbin.org
  " +
  *   "Connection: close
  
  ";
  * await stream.write(Buffer.from(request));
  * await stream.flush();
  * ```
  */
  write(src: Buffer): Promise<void>
  /**
  * Flushes this output stream, ensuring that all intermediately buffered contents reach their destination.
  */
  flush(): Promise<void>
  /**
  * Pulls some bytes from this source into the specified buffer.
  */
  read(len: number): Promise<Buffer>
  /**
  * Close the stream.
  */
  close(): Promise<void>
}
export type NativeStreamPrefs = StreamPrefs
export declare class StreamPrefs {
  constructor()
  static create(): NativeStreamPrefs
  /**
  * Indicate that we don't care which country a stream appears to come from.
  */
  anyExitCountry(): this
  /**
  * Indicate that a stream should appear to come from the given country.
  * When this option is set, we will only pick exit relays that have an IP address that matches the country in our GeoIP database.
  *
  *  @param country_code - A two-letter ISO 3166-1 alpha-2 country code, e.g. "IT" or "UY".
  */
  exitCountry(countryCode: string): this
  /**
  * Indicate whether connection to a hidden service (.onion service) should be allowed.
  */
  connectToOnionServices(value: boolean): this
  /**
  * ndicate that a stream may only be made over IPv4.
  * When this option is set, we will only pick exit relays that support IPv4, and we will tell them to only give us IPv4 connections.
  */
  ipv4Only(): this
  /**
  * Indicate that a stream may only be made over IPv6.
  * When this option is set, we will only pick exit relays that support IPv6, and we will tell them to only give us IPv6 connections.
  */
  ipv6Only(): this
  /**
  * Indicate that a stream may be made over IPv4 or IPv6, but that we'd prefer IPv4.
  * This is the default.
  */
  ipv4Preferred(): this
  /**
  * Indicate that a stream may be made over IPv4 or IPv6, but that we'd prefer IPv6.
  */
  ipv6Preferred(): this
  /**
  * Return true if this stream has been configured as "optimistic".
  */
  isOptimistic(): boolean
  /**
  * Indicate that no connection should share a circuit with any other.
  * Use with care: This is likely to have poor performance, and imposes a much greater load on the Tor network. Use this option only to make small numbers of connections each of which needs to be isolated from all other connections.
  * (Don't just use this as a "get more privacy!!" method: the circuits that it put connections on will have no more privacy than any other circuits. The only benefit is that these circuits will not be shared by multiple streams.)
  */
  isolateEveryStream(): this
  /**
  * Indicate that connections with these preferences should have their own isolation group.
  */
  newIsolationGroup(): this
  /**
  * Indicate that the stream should be opened "optimistically".
  * By default, streams are not "optimistic". When you call TorClient.connect, it won't give you a stream until the exit node has confirmed that it has successfully opened a connection to your target address. It's safer to wait in this way, but it is slower: it takes an entire round trip to get your confirmation.
  * If a stream is configured to be "optimistic", on the other hand, then TorClient.connect() will return the stream immediately, without waiting for an answer from the exit. You can start sending data on the stream right away, though of course this data will be lost if the connection is not actually successful.
  */
  optimistic(): this
}
